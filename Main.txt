% V-Bending Simulation with V-Groove - Research-like (mesh+contact+plasticity+springback)
clear variables; close all; clc;

%% ---------- INPUTS ----------
% Sheet dimensions
L = 55e-3;      % Length (m)
W = 32e-3;      % Width (m) - dùng để tham khảo, mô hình 2D theo chiều dày
t = 1.2e-3;     % Sheet thickness (m)

% V-groove parameters
d_over_t = 0.6;            % 0.2 / 0.4 / 0.6
d  = d_over_t * t;         % Groove depth
R_g = 0.8e-3;              % Groove nose radius
V_groove_angle = pi/2;     % 90 deg

% Tool geometry (AMADA-like)
R_p = 0.6e-3;   % Punch tip radius
R_s = 2.5e-3;   % Die shoulder radius (tham khảo)
S   = 12e-3;    % Die span (shoulder-to-shoulder)
tool_angle = 86 * pi/180;  % rad

% Material (SS400-like)
E   = 213e9;    % Pa
nu  = 0.3;
sigma_y = 348e6;  % initial yield (Pa)

% Plastic model (bilinear simplified)
H_iso = 2.0e9;     % isotropic hardening tangent (Pa) ~ điều chỉnh để có springback hợp lý
C      = E/(1-nu^2)*[1, nu, 0; nu, 1, 0; 0, 0, (1-nu)/2]; % elastic
C_tan  = C;                           % sẽ thay bằng C_elasto-plastic nếu muốn (simple)
C_inv  = inv(C);                      % dùng trong return-mapping giản lược

% Mesh controls
num_layers_thickness = 10;            % 10 layers through thickness
num_blocks = 5;
num_elem_per_block = [20, 70, 50, 70, 20];  % focus near groove
total_elements_x = sum(num_elem_per_block);

%% ---------- GEOMETRY & MESH ----------
fprintf('\n=== TRIỂN KHAI MESH THEO CHIẾN LƯỢC 5 BLOCKS ===\n');
groove_width = 2 * (d + R_g * (sqrt(2)-1));
fprintf('- Chiều rộng rãnh thực tế: %.3f mm\n', groove_width*1000);

block_ratios  = [0.35, 0.125, 0.05, 0.125, 0.35];
block_widths  = block_ratios * L;
x_boundaries  = -L/2;
for i = 1:num_blocks, x_boundaries(i+1) = x_boundaries(i) + block_widths(i); end

fprintf('\n--- THÔNG TIN BLOCKS ---\n');
for i = 1:num_blocks
    fprintf('Block %d: %.1f%%, [%.3f, %.3f] mm, %d elems\n', ...
        i, block_ratios(i)*100, x_boundaries(i)*1000, x_boundaries(i+1)*1000, num_elem_per_block(i));
end

% Build nodes (block-structured, share vertical boundary columns)
fprintf('\nĐang tạo nodes...\n');
nodes = [];
node_id = 1;
block_nodes_start = zeros(1,num_blocks);
for b = 1:num_blocks
    x_start = x_boundaries(b);  x_end = x_boundaries(b+1);
    nx = num_elem_per_block(b);
    x_block = linspace(x_start, x_end, nx+1);
    if b > 1
        x_block = x_block(2:end); % bỏ cột chung (share)
        block_start_node = node_id - (num_layers_thickness+1);
    else
        block_start_node = node_id;
    end
    block_nodes_start(b) = block_start_node;

    for ii = 1:length(x_block)
        x = x_block(ii);

        if x >= -groove_width/2 && x <= groove_width/2
            if abs(x) <= R_g*cos(pi/4)
                y_top = t - d + R_g - sqrt(max(R_g^2 - x^2, 0));
            else
                x_rel = abs(x) - R_g*cos(pi/4);
                y_top = t - d + R_g*(1 - sin(pi/4)) + x_rel*tan(pi/4);
            end
        else
            y_top = t;
        end

        for j = 1:(num_layers_thickness+1)
            y = (j-1)/num_layers_thickness * y_top;
            nodes(node_id,:) = [x, y];
            node_id = node_id + 1;
        end
    end
end
n_nodes = size(nodes,1);
fprintf('Hoàn thành: %d nodes\n', n_nodes);

% Elements (Q4)
fprintf('Đang tạo phần tử...\n');
elements = [];
elem_id = 1;
for b = 1:num_blocks
    nx = num_elem_per_block(b);
    bstart = block_nodes_start(b);
    for i = 1:nx
        for j = 1:num_layers_thickness
            n1 = bstart + (i-1)*(num_layers_thickness+1) + (j-1);
            n2 = n1 + 1;
            n3 = n1 + (num_layers_thickness+1) + 1;
            n4 = n1 + (num_layers_thickness+1);
            % thứ tự [n1 n4 n3 n2] (counter-clockwise) giúp J>0 ổn định hơn
            elements(elem_id,:) = [n1, n4, n3, n2];
            elem_id = elem_id + 1;
        end
    end
end
n_elements = size(elements,1);
fprintf('Hoàn thành: %d phần tử\n', n_elements);

% Quick aspect ratio check
ar = zeros(1, min(100,n_elements));
for e = 1:length(ar)
    coords = nodes(elements(e,:), :);
    dx = max(coords(:,1)) - min(coords(:,1));
    dy = max(coords(:,2)) - min(coords(:,2));
    ar(e) = max(dx/dy, dy/dx);
end
fprintf('\n--- KIỂM TRA CHẤT LƯỢNG MESH ---\n');
fprintf('- Tỷ lệ khung trung bình (100 elems): %.2f (khuyên <~5)\n', mean(ar));
fprintf('- Tỷ lệ khung max (100 elems): %.2f\n', max(ar));

% Visual check mesh
figure('Name','Mesh by blocks','Position',[100,100,1000,400]); hold on;
colors = lines(num_blocks);
offset = 0;
for b = 1:num_blocks
    es = sum(num_elem_per_block(1:b-1))*num_layers_thickness + 1;
    ee = es + num_elem_per_block(b)*num_layers_thickness - 1;
    patch('Faces', elements(es:ee,:), 'Vertices', nodes*1000, ...
        'FaceColor', colors(b,:), 'FaceAlpha', 0.15, 'EdgeColor', 'k', 'LineWidth', 0.5);
end
axis equal; xlabel('x (mm)'); ylabel('y (mm)'); title('Structured mesh (mm)'); box on;

%% ---------- GLOBAL ARRAYS ----------
dof_per_node = 2;
n_dof = n_nodes*dof_per_node;
K_global = sparse(n_dof, n_dof);  % not used directly in plastic loops (we reassemble)
F_global = zeros(n_dof,1);
U = zeros(n_dof,1);

% Gauss (2x2)
gp = [-1/sqrt(3), +1/sqrt(3)];
gw = [1, 1];

%% ---------- DIE SURFACE ----------
% V-die sharp: y = 0 ngoài vai, y = -((S/2)-|x|) trong lòng V
% ==== DIE GEOMETRY with bottom fillet r ====
r_die = 1e-3;                 % <-- bán kính đáy khuôn (điều chỉnh 0.6–1.5 mm)
yc    = -S/2 + r_die;           % tâm cung tròn (0, yc)

yV  = @(x) -((S/2) - abs(x));                                % hai cạnh V (độ dốc ±1)
yC  = @(x) yc + sqrt(max(r_die^2 - x.^2, 0));                % cung tròn đáy
y_die = @(x) min(0, (abs(x)<=r_die).*yC(x) + (abs(x)>r_die).*yV(x));


%% ---------- BOUNDARY CONDITIONS + PUNCH ----------
fixed_dofs  = zeros(0,1);
punch_nodes = zeros(0,1);

tolY = 1e-12;
bottom = find(abs(nodes(:,2)) < tolY);

% Support bands at shoulders (±S/2), lock uy
w_sh = 2.0e-4;  % 0.2 mm quanh ±S/2 (trước code dùng 1.0e-3)
left_sup  = bottom( abs(nodes(bottom,1) + S/2) <= w_sh );
right_sup = bottom( abs(nodes(bottom,1) - S/2) <= w_sh );
if ~isempty(left_sup),  fixed_dofs = [fixed_dofs; 2*left_sup(:)];  end
if ~isempty(right_sup), fixed_dofs = [fixed_dofs; 2*right_sup(:)]; end

% Anti-rigid body: lock ux of one node on left band (or any bottom)
if ~isempty(left_sup)
    fixed_dofs = [fixed_dofs; 2*left_sup(1)-1];
else
    fixed_dofs = [fixed_dofs; 2*bottom(1)-1];
end

% --- PUNCH: dải hẹp quanh tâm, ép đều vài lớp trên cùng ---
punch_displacement = 1.2e-3;      % bạn đã giảm rồi, giữ giá trị đang dùng
dx_avg   = L / sum(num_elem_per_block);
band_half = max(R_p, 2*dx_avg);     % rộng hơn để tránh "kim" ở giữa

top_layers = max(2, round(0.15*(num_layers_thickness+1)));


U_bc = zeros(n_dof,1);
punch_nodes = zeros(0,1);

xs = unique(nodes(:,1))';
for xi = xs
    if abs(xi) <= band_half + 1e-12
        col_idx = find( abs(nodes(:,1) - xi) < 1e-12 );

        % sắp theo y giảm dần để lấy các nút "trên cùng"
        [~, ord] = sort(nodes(col_idx,2), 'descend');
        pick = col_idx(ord(1:min(top_layers, numel(ord))));   % 2–3 lớp trên

        punch_nodes = [punch_nodes; pick(:)];
        % khóa DOF-Y của các nút này và gán dịch chuyển như nhau
        fixed_dofs = [fixed_dofs; 2*pick(:)];
        U_bc(2*pick) = -punch_displacement;
    end
end

fixed_dofs = unique(fixed_dofs(:));

punch_nodes = unique(punch_nodes(:));

%% ---------- PLASTIC STATE STORAGE ----------
% eps_p per element per Gauss point (Voigt [exx; eyy; gxy]), 4 GP
eps_p = cell(n_elements,1);
p_eq  = cell(n_elements,1);
for e = 1:n_elements
    eps_p{e} = zeros(3,4);  % 3 comps x 4 GP
    p_eq{e}  = zeros(1,4);  % 1 x 4 GP
end

%% ---------- HELPERS ----------
% (local functions are at end of script)
% get_B_detJ(node_coords,xi,eta)
% vmises(s)          % von Mises from [sx;sy;txy]
% elastic_return(sig_tr)  % simple projector with bilinear-like scaling
% Note: for a more exact bilinear, replace projector by consistent EP return-mapping.

%% ================== PHASE 1: LOADING (CONTACT + ELASTO-PLASTIC) ==================
U = zeros(n_dof,1); U(fixed_dofs) = U_bc(fixed_dofs);
max_outer = 6;      % contact iterations
max_inner = 4;      % plastic correction iterations per contact step
tol_contact = 1e-9;

for it_out = 1:max_outer
    % ---- plastic iterations with fixed contact set ----
    for it_in = 1:max_inner
        fixed_dofs = unique(fixed_dofs(:));
        free_dofs  = setdiff((1:n_dof)', fixed_dofs);

        K_ff = sparse(length(free_dofs), length(free_dofs));
        K_fc = sparse(length(free_dofs), length(fixed_dofs));
        F_f  = zeros(length(free_dofs),1);
        f_p_global = zeros(n_dof,1);   % ∫ B' C eps_p dV

        for e = 1:n_elements
            elem_nodes  = elements(e,:);
            node_coords = nodes(elem_nodes,:);

            dof_idx = zeros(1,8);
            for k = 1:4
                dof_idx(2*k-1) = 2*elem_nodes(k)-1;
                dof_idx(2*k)   = 2*elem_nodes(k);
            end

            K_e = zeros(8,8); f_p_e = zeros(8,1);
            gp_id = 0;
            for i = 1:2
                for j = 1:2
                    xi = gp(i); wi = gw(i);
                    eta= gp(j); wj = gw(j);
                    [B, detJ, ok] = get_B_detJ(node_coords, xi, eta);
                    if ~ok, continue; end
                    gp_id = gp_id + 1;

                    eps_p_gp = eps_p{e}(:,gp_id);
                    f_p_e = f_p_e + (B'*C*eps_p_gp) * detJ * wi * wj;
                    % dùng C (elastic tangent) + plastic load term
                    K_e   = K_e   + (B'*C*B) * detJ * wi * wj;
                end
            end

            % assemble to global split (f/c)
            [~,loc_f] = ismember(dof_idx, free_dofs);
            [~,loc_c] = ismember(dof_idx, fixed_dofs);
            mask_f = loc_f>0; idx_f = loc_f(mask_f);
            mask_c = loc_c>0; idx_c = loc_c(mask_c);
            K_ff(idx_f, idx_f) = K_ff(idx_f, idx_f) + K_e(mask_f, mask_f);
            if any(mask_c), K_fc(idx_f, idx_c) = K_fc(idx_f, idx_c) + K_e(mask_f, mask_c); end
            f_p_global(dof_idx) = f_p_global(dof_idx) + f_p_e;
        end

        % solve
        U(fixed_dofs) = U_bc(fixed_dofs);
        rhs = F_f + f_p_global(free_dofs) - K_fc*U(fixed_dofs);
        U(free_dofs) = K_ff \ rhs;

      % ---- update plastic strain at Gauss points (bilinear iso-hardening) ----
any_update = false;
for e = 1:n_elements
    elem_nodes  = elements(e,:);
    node_coords = nodes(elem_nodes,:);
    dof_idx = zeros(1,8);
    for k = 1:4
        dof_idx(2*k-1) = 2*elem_nodes(k)-1;
        dof_idx(2*k)   = 2*elem_nodes(k);
    end
    Ue = U(dof_idx);

    gp_id = 0;
    for i = 1:2
        for j = 1:2
            xi = gp(i); eta = gp(j);
            [B, detJ, ok] = get_B_detJ(node_coords, xi, eta);
            if ~ok, continue; end
            gp_id = gp_id + 1;

            eps_p_gp = eps_p{e}(:,gp_id);
            p_eq_gp  = p_eq{e}(gp_id);

            eps    = B*Ue;                    % total strain
            sig_tr = C*(eps - eps_p_gp);      % trial stress

            [sig_proj, eps_p_new, p_eq_new] = ep_return_bilinear( ...
                 sig_tr, eps_p_gp, p_eq_gp, sigma_y, H_iso, C, nu);

            % Nếu có chảy dẻo (khác trial) thì cập nhật
            if max(abs(sig_proj - sig_tr)) > 1e-12
                eps_p{e}(:,gp_id) = eps_p_new;
                p_eq{e}(gp_id)    = p_eq_new;
                any_update = true;
            end
        end
    end
end
if ~any_update, break; end
    end

    % ---- contact update w.r.t V-die ----
    Uy = U(2:2:end);
    Y_def = nodes(:,2) + Uy;
    Y_die_now = arrayfun(y_die, nodes(:,1));

    viol = find(Y_def < (Y_die_now - tol_contact));
    if isempty(viol), break; end
    dofY_viol = 2*viol(:);
    U(dofY_viol) = (Y_die_now(viol) - nodes(viol,2));
    fixed_dofs = unique([fixed_dofs; dofY_viol]);
end

U_load = U;  % under-load shape (đang tì chày)

%% ================== PHASE 2: UNLOADING (SPRINGBACK) ==================
% Thả các DOF y của nút chày, giữ vùng vai & các nút đang chạm khuôn
dofY_punch = 2*punch_nodes(:);
fixed_dofs = setdiff(fixed_dofs(:), dofY_punch);
U_bc(dofY_punch) = 0;

U = zeros(n_dof,1);
U(fixed_dofs) = U_bc(fixed_dofs);

max_outer_un = 6;  max_inner_un = 2;
for it_out = 1:max_outer_un
    for it_in = 1:max_inner_un
        fixed_dofs = unique(fixed_dofs(:));
        free_dofs  = setdiff((1:n_dof)', fixed_dofs);

        K_ff = sparse(length(free_dofs), length(free_dofs));
        K_fc = sparse(length(free_dofs), length(fixed_dofs));
        F_f  = zeros(length(free_dofs),1);
        f_p_global = zeros(n_dof,1);

        for e = 1:n_elements
            elem_nodes  = elements(e,:);
            node_coords = nodes(elem_nodes,:);
            dof_idx = zeros(1,8);
            for k = 1:4
                dof_idx(2*k-1) = 2*elem_nodes(k)-1;
                dof_idx(2*k)   = 2*elem_nodes(k);
            end

            K_e = zeros(8,8); f_p_e = zeros(8,1);
            gp_id = 0;
            for i = 1:2
                for j = 1:2
                    xi = gp(i); wi = gw(i);
                    eta= gp(j); wj = gw(j);
                    [B, detJ, ok] = get_B_detJ(node_coords, xi, eta);
                    if ~ok, continue; end
                    gp_id = gp_id + 1;

                    eps_p_gp = eps_p{e}(:,gp_id);
                    f_p_e = f_p_e + (B'*C*eps_p_gp) * detJ * wi * wj;
                    K_e   = K_e   + (B'*C*B) * detJ * wi * wj;
                end
            end

            [~,loc_f] = ismember(dof_idx, free_dofs);
            [~,loc_c] = ismember(dof_idx, fixed_dofs);
            mask_f = loc_f>0; idx_f = loc_f(mask_f);
            mask_c = loc_c>0; idx_c = loc_c(mask_c);
            K_ff(idx_f, idx_f) = K_ff(idx_f, idx_f) + K_e(mask_f, mask_f);
            if any(mask_c), K_fc(idx_f, idx_c) = K_fc(idx_f, idx_c) + K_e(mask_f, mask_c); end
            f_p_global(dof_idx) = f_p_global(dof_idx) + f_p_e;
        end

        U(fixed_dofs) = U_bc(fixed_dofs);
        rhs = F_f + f_p_global(free_dofs) - K_fc*U(fixed_dofs);
        U(free_dofs) = K_ff \ rhs;
    end

    % contact check with die
    Uy = U(2:2:end);
    Y_def = nodes(:,2) + Uy;
    Y_die_now = arrayfun(y_die, nodes(:,1));
    viol = find(Y_def < (Y_die_now - tol_contact));
    if isempty(viol), break; end
    dofY_viol = 2*viol(:);
    U(dofY_viol) = (Y_die_now(viol) - nodes(viol,2));
    fixed_dofs = unique([fixed_dofs; dofY_viol]);
end

U_springback = U;  % after springback


%% ---------- POSTPROCESS ----------
% Chọn trạng thái để hậu xử lý:
use_under_load = false;     % =true để xem đang tì chày; =false để xem sau springback
U_for_post = U_springback; 
if use_under_load, U_for_post = U_load; end




% Stress at element centers (from elastic law and current plastic strain)
stress = zeros(n_elements,3);   % [sx, sy, txy] at center (xi=0,eta=0)
for e = 1:n_elements
    elem_nodes  = elements(e,:);
    node_coords = nodes(elem_nodes,:);
    dof_idx = zeros(1,8);
    for k = 1:4
        dof_idx(2*k-1) = 2*elem_nodes(k)-1;
        dof_idx(2*k)   = 2*elem_nodes(k);
    end
    Ue = U_for_post(dof_idx);
    [B0, detJ0, ok] = get_B_detJ(node_coords, 0, 0);
    if ~ok, continue; end
    % approx plastic strain at center = average of 4 GP
    eps_p_e = mean(eps_p{e},2);
    strain  = B0*Ue;
    s       = C*(strain - eps_p_e);
    stress(e,:) = s.';
end

% Nodal averaging
sigma_xx_nodes = zeros(n_nodes,1);
sigma_yy_nodes = zeros(n_nodes,1);
sigma_xy_nodes = zeros(n_nodes,1);
count_nodes    = zeros(n_nodes,1);
for e = 1:n_elements
    en = elements(e,:);
    sigma_xx_nodes(en) = sigma_xx_nodes(en) + stress(e,1);
    sigma_yy_nodes(en) = sigma_yy_nodes(en) + stress(e,2);
    sigma_xy_nodes(en) = sigma_xy_nodes(en) + stress(e,3);
    count_nodes(en)    = count_nodes(en)    + 1;
end
sigma_xx_nodes = sigma_xx_nodes ./ max(count_nodes,1);
sigma_yy_nodes = sigma_yy_nodes ./ max(count_nodes,1);
sigma_xy_nodes = sigma_xy_nodes ./ max(count_nodes,1);

vm = sqrt( sigma_xx_nodes.^2 + sigma_yy_nodes.^2 - sigma_xx_nodes.*sigma_yy_nodes + 3*sigma_xy_nodes.^2 );
fprintf('\n[INFO] Max von Mises (nodal): %.3e Pa\n', max(vm));



% ==== MEASURE BEND ANGLE alpha AFTER SPRINGBACK ====
def_nodes = nodes + [U_for_post(1:2:end), U_for_post(2:2:end)];

% Chọn các điểm ở "cánh" xa rãnh, gần mặt trên (ổn định để fit)
mask_top   = nodes(:,2) > 0.8*t;                               % gần mặt trên
offset_x   = groove_width/2 + 3e-3;                            % cách rãnh >= 3 mm
mask_left  = mask_top & (nodes(:,1) < -offset_x);
mask_right = mask_top & (nodes(:,1) >  +offset_x);

Lpts = def_nodes(mask_left ,:);
Rpts = def_nodes(mask_right,:);

% Fit đường thẳng y = a*x + b cho mỗi cánh
pL = polyfit(Lpts(:,1), Lpts(:,2), 1);
pR = polyfit(Rpts(:,1), Rpts(:,2), 1);
mL = pL(1);  mR = pR(1);

% Góc giữa hai đường: phi = arctan(|(m2-m1)/(1+m1*m2)|)
phi = atan( abs( (mR - mL) / max(1 + mR*mL, 1e-12) ) ); % (rad)

% Góc mở bên trong hình chữ V:
alpha_deg = 180 - rad2deg(phi);
fprintf('>> Bend angle alpha (after springback) ≈ %.2f deg\n', alpha_deg);

% Plots
figure('Name','Sigma_xx'); patch('Faces',elements,'Vertices',nodes, ...
    'FaceVertexCData',sigma_xx_nodes,'FaceColor','interp','EdgeColor','k'); 
colormap('jet'); colorbar; axis equal; title('\sigma_{xx} (Pa)');

figure('Name','Sigma_yy'); patch('Faces',elements,'Vertices',nodes, ...
    'FaceVertexCData',sigma_yy_nodes,'FaceColor','interp','EdgeColor','k'); 
colormap('jet'); colorbar; axis equal; title('\sigma_{yy} (Pa)');

figure('Name','Sigma_xy'); patch('Faces',elements,'Vertices',nodes, ...
    'FaceVertexCData',sigma_xy_nodes,'FaceColor','interp','EdgeColor','k'); 
colormap('jet'); colorbar; axis equal; title('\sigma_{xy} (Pa)');

figure('Name','Von Mises'); patch('Faces',elements,'Vertices',nodes, ...
    'FaceVertexCData',vm,'FaceColor','interp','EdgeColor','k'); 
colormap('jet'); colorbar; axis equal; title('von Mises (Pa)');

%% ---------- COMBINED PLOT: ORIGINAL + DEFORMED ----------
figure('Name','Original vs Deformed','Position',[200,200,600,800]); hold on;

Uplot = [U_for_post(1:2:end), U_for_post(2:2:end)];
def_nodes = nodes + Uplot;

% --- Hình gốc (màu xanh) ---
patch('Faces',elements,'Vertices',nodes, ...
      'FaceColor','none','EdgeColor','b','LineWidth',0.5);
  
% --- Hình biến dạng (màu đỏ) ---
patch('Faces',elements,'Vertices',def_nodes, ...
      'FaceColor','none','EdgeColor','r','LineWidth',0.8);

axis equal;
xlabel('x (m)'); ylabel('y (m)');
title(sprintf('Original (blue) vs Deformed (x%d, red)',1));
legend({'Original','Deformed'},'Location','southoutside');
box on; grid on;
